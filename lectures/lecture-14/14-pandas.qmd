---
title: QTM 350 - Data Science Computing
subtitle: Lecture 14 - Introduction to Pandas
date: 2024-10-21
date-format: "DD MMMM, YYYY"
author:
  - name: Danilo Freire
    email: danilo.freire@emory.edu
    affiliations: Emory University
format:
  clean-revealjs:
    self-contained: true
    code-overflow: wrap
    footer: "[Pandas](https://raw.githack.com/danilofreire/qtm350/main/lectures/lecture-14/14-pandas.html)"
    drop:
      button: true
      engine: pyodide
      pyodide:
        packages:
          - matplotlib
          - numpy
          - pandas
transition: slide
transition-speed: default
scrollable: true
engine: jupyter
revealjs-plugins:
  - appearance
  - drop
  - fontawesome
  - multimodal
editor:
  render-on-save: true
---

# Hello, everyone! üëã {background-color="#2d4563"}

# I've made something! <br> Let me know if it works üêç {background-color="#2d4563"}

## Jupyter Notebooks online üåê

:::{style="margin-top: 30px; font-size: 22px;"}
:::{.columns}
:::{.column width="50%"}
- New users find it challenging to install Python and Jupyter Notebook on their computers
- So I've made a [Jupyter Notebook online]{.alert} that you can use to run Python code [without installing anything!]{.alert} ü§ì
- I've used [Pyodide](https://pyodide.org/en/stable/){data-modal-type="iframe"} and [JupyterLite](https://jupyterlite.readthedocs.io/){data-modal-type="iframe"} to run Python code in the browser
- You can access it on the [Jupyter Lite tab on the course website](https://danilofreire.github.io/qtm350/){data-modal-type="iframe"}
- The website is <https://danilofreire.github.io/qtm350/jupyter>
:::

:::{.column width="50%"}
- It already comes with all packages we need for this class, such as NumPy, Pandas, Matplotlib, and Seaborn
- You can install many other packages too! üì¶
- Not all Python packages work, but many do. Install them with 

```python
%pip install package-name
```

- You can also use it to run `R` and `JavaScript` code, as well as write `LaTeX` and `Markdown` documents
- [Please download your files with the right-click menu before closing the browser!]{.alert}
- Let me know if you find any bugs! üêû
:::
:::
:::


# Brief recap of the last lecture {background-color="#2d4563"}

## Introduction to Python üêç

:::{style="margin-top: 30px; font-size: 22px;"}
:::{.columns}
:::{.column width="50%"}
- In the last lecture, we had a brief introduction to Python
- We covered the main concepts of the language, such as variables, operators, control structures, and functions
- We also saw how to install Python and Jupyter Notebook
- We briefly discussed the various data types in Python, such as integers, floats, strings, lists, tuples, and dictionaries
- We finished with for loops, if statements, and functions
- Today we will see lean more about [Numpy](https://numpy.org) and, more importantly, [Pandas](https://pandas.pydata.org/)
:::

:::{.column width="50%"}
:::{style="text-align: center;"}
![](figures/numpy.png)
![](figures/pandas.png)
:::
:::
:::
:::

# Numpy üßÆ {background-color="#2d4563"}

## Numpy arrays

:::{style="margin-top: 30px; font-size: 21px;"}
:::{.columns}
:::{.column width="50%"}
#### What is Numpy?

- NumPy stands for "Numerical Python" and it is the standard Python library used for working with arrays (i.e., vectors & matrices), linear algebra, and other numerical computations 
- NumPy is written in C, making NumPy arrays [faster and more memory efficient than Python lists]{.alert}
- If you have Anaconda installed, you already have NumPy installed too. But if you don't, you can install it using `conda install numpy` or `pip install numpy`
- In Python, we export packages with the `import` command. 
- It is also common to use [aliases](https://www.datacamp.com/tutorial/modules-in-python) to make the code shorter and more readable. Numpy's is `np`

```{python}
#| echo: true
#| eval: true
import numpy as np 
```
:::

:::{.column width="50%"}
#### What is an array?

- Arrays are "n-dimensional" data structures that can contain all the basic Python data types, e.g., floats, integers, strings etc 
- However, they work best with numeric data
- NumPy arrays (`ndarrays`) are homogenous, which means that items in the array should be of the same type. 
- `ndarrays` are also compatible with numpy's vast collection of in-built functions!

:::{style="text-align: center;"}
![](figures/array.png){width="70%"}
:::
:::
:::
:::

## Creating arrays

:::{style="margin-top: 30px; font-size: 21px;"}
:::{.columns}
:::{.column width="50%"}
- A numpy array is sort of like a list, but with more functionality

```{python}
#| echo: true
#| eval: true
my_list = [1, 2, 3, 4, 5]
my_list
```

```{python}
#| echo: true
#| eval: true
my_array = np.array([1, 2, 3, 4, 5])
my_array
```

- But it has the type `numpy.ndarray`

- Unlike a list, arrays can only hold a single type (usually numbers). Check this out

```{python}
#| echo: true
#| eval: true
my_list = [1, "hi"]
my_list
```

```{python}
#| echo: true
#| eval: true
my_array = np.array([1, "hi"])
my_array
``` 
 
- Above: NumPy converted the integer 1 into the string `'1'`!
:::

:::{.column width="50%"}
- `ndarrays` are typically created using two main methods:
  - From existing data using `np.array()`
  - Using built-in functions like `np.zeros()`, `np.ones()`, `np.arange()`, `np.linspace()`, `np.random.normal()`, etc.
- Let's see some examples

```{python}
#| echo: true
#| eval: true
my_list = [1, 2, 3]
np.array(my_list)
```
```{python}
#| echo: true
#| eval: true
np.arange(1, 10, 2)  # from 1 inclusive to 10 exclusive, step 2
```

```{python}
#| echo: true
#| eval: true
np.linspace(0, 10, 5) # from 0 to 10, 5 numbers
```

- You can have multi-dimensional arrays (indicated by double square brackets `[[ ]]`):

```{python}
#| echo: true
#| eval: true
np.array([[1, 2, 3], [4, 5, 6]])
```
:::
:::
:::

## Array operations

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="50%"}
- Arrays can be used in [arithmetic operations]{.alert}, such as addition, subtraction, multiplication, and division
- These operations are performed element-wise, meaning that [the operation is applied to each element in the array]{.alert}

```{python}
#| echo: true
#| eval: true
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
a + b
```

```{python}
#| echo: true
#| eval: true
a * b
```

- You can also apply functions to arrays, such as `np.sqrt()`, `np.exp()`, `np.log()`, `np.sin()`, `np.cos()`, `np.tan()`, etc. Please check the [documentation](https://numpy.org/doc/stable/reference/arrays.ndarray.html#array-methods) for more information
 
```{python}
#| echo: true
#| eval: true
np.sqrt(a)
```

```{python}
#| echo: true
#| eval: true
np.exp(a)
```
:::

:::{.column width="50%"}
- You can also apply logical operations to arrays, such as `==`, `!=`, `>`, `<`, `>=`, `<=`, etc.
- These operations return boolean arrays

```{python}
#| echo: true
#| eval: true
a == b
```

```{python}
#| echo: true
#| eval: true
a < b
```

- You can call (most of) these functions on the array itself using the [dot notation](https://builtin.com/data-science/dot-notation) `a.sum()`, `a.mean()`, `a.max()`, `a.min()`, etc.
  - A dot "." basically means "in here"

```{python}
#| echo: true
#| eval: true
a.sum()
```

```{python}
#| echo: true
#| eval: true
a.mean()
```

```{python}
#| echo: true
#| eval: true
a.max()
```

:::
:::
:::

## Broadcasting

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="50%"}
- Broadcasting allows NumPy to work with arrays of different shapes when performing arithmetic operations
- The smaller array is "broadcast" across the larger array so that they have compatible shapes
- So it substitues `for` loops in many cases! üòÖ
- One example is adding a scalar to an array

```{python}
#| echo: true
#| eval: true
cost = np.array([20, 15, 25])
print("Pie cost:")
print(cost)
```

```{python}
#| echo: true
#| eval: true
sales = np.array([[2, 3, 1], [6, 3, 3], [5, 3, 5]])
print("\nPie sales (#):")
print(sales)
```
- How do we make them the same size?
:::

:::{.column width="50%"}
![](figures/pies_broadcast.png){width="100%"}

- We can broadcast the cost array to the sales array
- We will use the `np.repeat()` function to do this

```{python}
#| echo: true
#| eval: true
cost = np.repeat(cost, 3).reshape((3, 3))
cost
```

- Now we can calculate the total sales

```{python}
#| echo: true
#| eval: true
total_sales = cost * sales
total_sales
```

- Wohoo! ü•≥ Much easier than creating a loop 
:::
:::
:::

## Indexing and slicing

:::{style="margin-top: 30px; font-size: 21px;"}
:::{.columns}
:::{.column width="50%"}
#### Numeric indexing

- Indexing arrays is similar to indexing lists but there are just more dimensions
- We use square brackets `[]` to index arrays
- Colons `:` are used to slice arrays

```{python}
#| echo: true
#| eval: true
x = np.arange(10)
x
```

```{python}
#| echo: true
#| eval: true
x[3]
```

```{python}
#| echo: true
#| eval: true
x[2:5]
```

```{python}
#| echo: true
#| eval: true
x[2:]
```

```{python}
#| echo: true
#| eval: true
x[-1]
```

```{python}
#| echo: true
#| eval: true
x[5:0:-1] # reverse
```
:::

:::{.column width="50%"}
#### Multi-dimensional arrays

- For multi-dimensional arrays, we use commas to separate the indices
- The first index refers to the row, the second to the column, and so on

```{python}
#| echo: true
#| eval: true
x = np.random.randint(10, size=(4, 6))
x
```

```{python}
#| echo: true
#| eval: true
x[3, 4]
```

```{python}
#| echo: true
#| eval: true
x[2, :]
```

```{python}
#| echo: true
#| eval: true
x[:, 3]
```

```{python}
#| echo: true
#| eval: true
x[2:, :3]
```
:::
:::
:::

# Pandas! üêº {background-color="#2d4563"}

## Pandas is pretty cool! üêº
### Pandas Series

:::{style="margin-top: 30px; font-size: 21px;"}
- Pandas is the most popular Python library for tabular data structures
- Think of Pandas as an extremely powerful version of Excel or `dplyr` + `tibble` in `R`
- Pandas is built on top of NumPy, so it is fast and memory efficient
- Pandas has two main data structures: `Series` and `DataFrame`
- A `Series` is a one-dimensional array with an index, pretty much like a `np.array`, but [with a label for each element]{.alert}
  - They are [strictly one-dimensional]{.alert}
- You can create a `Series` from a list, a NumPy array, a dictionary, or a scalar value using `pd.Series()` (note the capital "S")
- You import pandas with `import pandas as pd`
:::

## Creating Series

:::{style="margin-top: 30px; font-size: 21px;"}
:::{.columns}
:::{.column width="50%"}
![](figures/series.png)

```{python}
#| echo: true
#| eval: true
import pandas as pd

pd.Series(data = [-5, 1.3, 21, 6, 3])
```
:::

:::{.column width="50%"}
- The left column is the index, and the right column is the data
- If you don't specify an index, Pandas will create one for you
- But you can add a custom index:

```{python}
#| echo: true
#| eval: true
pd.Series(data = [-5, 1.3, 21, 6, 3],
          index = ['a', 'b', 'c', 'd', 'e'])

```

- You can create a Series from a dictionary:

```{python}
#| echo: true
#| eval: true
pd.Series(data = {'a': 10, 'b': 20, 'c': 30})
```
:::
:::
:::

## Indexing and slicing Series

:::{style="margin-top: 30px; font-size: 21px;"}
:::{.columns}
:::{.column width="50%"}
- You can index and slice a `Series` like a NumPy array
- In fact, series can be passed to most NumPy functions! 
- They can be indexed using square brackets `[ ]` and sliced using colon `:` notation:

```{python}
#| echo: true
#| eval: true
s = pd.Series(data = range(5),
              index = ['A', 'B', 'C', 'D', 'E'])
s
```

```{python}
#| echo: true
#| eval: true
s[0]
```

```{python}
#| echo: true
#| eval: true
s['A']
```

```{python}
#| echo: true
#| eval: true
s[["B", "D", "C"]]
```
:::

:::{.column width="50%"}
- Note above how array-based indexing and slicing also returns the series index
- Finally, we can also do boolean indexing with series

```{python}
#| echo: true
#| eval: true
s[s >= 1]
```

```{python}
#| echo: true
#| eval: true
s[s > s.mean()]
```

```{python}
#| echo: true
#| eval: true
(s != 1)
```
:::
:::
:::

## Series operations

:::{style="margin-top: 30px; font-size: 19px;"}
:::{.columns}
:::{.column width="50%"}
- Series can be used in arithmetic operations, such as addition, subtraction, multiplication, and division
- Unlike `ndarrays`, operations between Series [align values based on their LABELS]{.alert} (not their position in the structure) 
- The resulting index will be the sorted union of the two indexes 

```{python}
#| echo: true
#| eval: true
s1 = pd.Series(data = range(4),
               index = ["A", "B", "C", "D"])
s1
```

```{python}
#| echo: true
#| eval: true
s2 = pd.Series(data = range(10, 14),
               index = ["B", "C", "D", "E"])
s2
```

```{python}
#| echo: true
#| eval: true
s1 + s2
```
:::

:::{.column width="50%"}
![](figures/series_operation.png)

- Indices that don't match will appear in the product but with NaN values
- NumPy also accepts series as an argument to most functions because series are built off numpy arrays

```{python}
#| echo: true
#| eval: true
np.exp(s1)
```

:::
:::
:::

# Pandas DataFrames üêº {background-color="#2d4563"}

## Pandas DataFrames

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="50%"}
- Pandas DataFrames are your new best friend üòÇ
- DataFrames are really just Series stuck together! 
- Think of a DataFrame as a dictionary of series, with the "keys" being the column labels and the "values" being the series data

![](figures/dataframe.png)
:::

:::{.column width="50%"}
- Dataframes can be created using `pd.DataFrame()` (note the capital "D" and "F")

```{python}
#| echo: true
#| eval: true
pd.DataFrame([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])
```

- We can use the `index` and `columns` arguments to give them labels:

```{python}
#| echo: true
#| eval: true
pd.DataFrame([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]],
             index = ["R1", "R2", "R3"],
             columns = ["C1", "C2", "C3"])
```
:::
:::
:::

## Creating DataFrames

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="50%"}
- DataFrames can be created from dictionaries, lists, NumPy arrays, and Series
- It is common to create DataFrames from dictionaries, where the keys are the column names and the values are the data

```{python}
#| echo: true
#| eval: true
pd.DataFrame({"C1": [1, 2, 3],
              "C2": ['A', 'B', 'C']},
             index=["R1", "R2", "R3"])

```
:::

:::{.column width="50%"}
- Usually, you will create a `DataFrame` from a CSV file using `pd.read_csv()`
- You can also create a `DataFrame` from an Excel file using `pd.read_excel()`
- Pandas can read from many other sources, such as SQL databases (as we will see in this course), JSON files, and even HTML tables

```{python}
#| echo: true
#| eval: true
df = pd.read_csv("data/iris.csv")
df.head()
```
:::
:::
:::

## Indexing and slicing DataFrames

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="50%"}
- There are several main ways to select data from a DataFrame:
  - Using square brackets `[ ]`, `.loc[]`, `.iloc[]`, Boolean indices, and `.query()`

```{python}
#| echo: true
#| eval: true
df = pd.DataFrame({"Name": ["Danilo", "Maria", "Lucas"],
                   "Language": ["Python", "Python", "R"],
                   "Courses": [5, 4, 7]})
df
```

- You can select a column using square brackets `[ ]` or dot notation `.`

```{python}
#| echo: true
#| eval: true
df["Name"]
```

```{python}
#| echo: true
#| eval: true
df.Name
```
:::

:::{.column width="50%"}
- You can select multiple columns by passing a list of column names

```{python}
#| echo: true
#| eval: true
df[["Name", "Courses"]]
```

- You can select rows using `.iloc[]`, which accepts [integers]{.alert} as references to rows/columns

```{python}
#| echo: true
#| eval: true
df.iloc[0]  # returns a series
```

```{python}
#| echo: true
#| eval: true
df.iloc[0:2]  # returns a dataframe
```
:::
:::
:::

## Indexing and slicing DataFrames

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="50%"}
- Now let's look at `.loc` which accepts [labels]{.alert} as references to rows/columns:

```{python}
#| echo: true
#| eval: true
df.loc[:, 'Name']
```

```{python}
#| echo: true
#| eval: true
df.loc[:, 'Name':'Language']
```

```{python}
#| echo: true
#| eval: true
df.loc[[0, 2], ['Language']]
```
:::

:::{.column width="50%"}
- Boolean indexing is also possible
  
```{python}
#| echo: true
#| eval: true
df[df["Courses"] > 5]
```

```{python}
#| echo: true
#| eval: true
df[df['Name'] == "Danilo"]
```
:::
:::
:::

## Indexing and slicing with `.query()`

:::{style="margin-top: 30px; font-size: 20px;"}
:::{.columns}
:::{.column width="50%"}
- The `.query()` method allows you to select data using a string expression
- It is my favourite method because it is more readable and less error-prone
- `.query()` accepts a string expression to evaluate and it "knows" the names of the columns in your dataframe

```{python}
#| echo: true
#| eval: true
df.query('Courses > 5')
```

```{python}
#| echo: true
#| eval: true
df.query('Name == "Danilo"')
```
:::

:::{.column width="50%"}
```{python}
#| echo: true
#| eval: true
df.query("Courses > 4 & Language == 'Python'")
```

- Note the use of single quotes AND double quotes above, lucky we have both in Python!

- You can also use the `@` symbol to reference variables in the environment

```{python}
#| echo: true
#| eval: true
min_courses = 5
df.query("Courses > @min_courses")
```
:::
:::
:::
